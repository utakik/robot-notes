<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>String Swing – Jointed Rope</title>
<style>
  html, body { height: 100%; margin: 0; background:#fff; }
  body { display:grid; place-items:center; font-family:system-ui, sans-serif; user-select:none; touch-action:manipulation; }

  /* 画面中央にSVGキャンバス */
  #stage { width:min(90vw,520px); height:min(70vh,520px); display:block; }

  /* 許可ボタン */
  #perm { position:fixed; inset:0; margin:auto; width:max(220px,40vw); padding:1rem 1.2rem;
          border:1px solid #888; border-radius:.6rem; background:#fff; font-size:16px; cursor:pointer;
          box-shadow:0 4px 16px rgba(0,0,0,.15); }
  #perm.hidden { display:none; }

  /* 簡易UI */
  #hud{ position:fixed; top:.6rem; left:50%; transform:translateX(-50%); font-size:12px; opacity:.65; }
</style>
</head>
<body>
  <svg id="stage" viewBox="0 0 400 400" aria-label="jointed rope">
    <!-- アンカー位置（見えない）: (200, 40) -->
    <path id="rope" d="" fill="none" stroke="#111" stroke-width="3" stroke-linecap="round" />
    <circle id="bob" cx="200" cy="200" r="4" fill="#111"/>
  </svg>

  <button id="perm" class="hidden">センサーを有効にする</button>
  <div id="hud">
  スマホは傾けて、PCはマウス移動/ドラッグで揺らせます。<br>
  <label><input type="checkbox" id="inv"> 反転（左右逆に感じたらON）</label>
</div>

<script>
/* ===== パラメータ（お好みで） ===== */
const NUM_SEG   = 16;     // 関節数（多いほど柔らかい）
const SEG_LEN   = 10;     // 各節の長さ（px）
const ITER      = 6;      // 制約反復（多いほどコシ強め）
const AIR_DAMP  = 0.005;   // 空気抵抗（0〜0.03）
const GRAVITY_Y = 600;    // 下向き重力 [px/s^2]
let   GAIN_X    = 1200;    // 横方向の力スケール（傾き→力）
let   DEADZONE  = 0.02;   // 小さな傾き無視
let invert = 1;
const invBox = document.getElementById('inv');
invBox.addEventListener('change', (e)=>{
invert = e.target.checked ? -1 : 1;
});

/* ===== 参照 ===== */
const svg  = document.getElementById('stage');
const rope = document.getElementById('rope');
const bob  = document.getElementById('bob');
const permBtn = document.getElementById('perm');

/* ===== ロープ状態（Verlet） ===== */
const N = NUM_SEG + 1; // 点の数
const pts = new Array(N).fill().map(_=>({x:0,y:0,px:0,py:0}));
const anchor = { x:200, y:40 }; // 固定点（SVG座標）

function resetRope(){
  for(let i=0;i<N;i++){
    const x = anchor.x;
    const y = anchor.y + i*SEG_LEN;
    pts[i].x=x; pts[i].y=y; pts[i].px=x; pts[i].py=y;
  }
}
resetRope();

/* ===== 画面向き（0/90/180/270） ===== */
function screenAngle(){
  if (screen.orientation && typeof screen.orientation.angle === 'number') return screen.orientation.angle;
  if (typeof window.orientation === 'number') return ((window.orientation%360)+360)%360;
  return 0;
}

/* ===== センサー入力：左右傾きだけ取り出す（弱い環境は0に近い） ===== */
let tiltX = 0; // -1..1 相当（画面の左右）
function toScreenAxes(ax, ay, angDeg){
  const t = angDeg * Math.PI/180, c = Math.cos(t), s = Math.sin(t);
  return { sx: ax*c + ay*s, sy: -ax*s + ay*c };
}
window.addEventListener('devicemotion', (e)=>{
  const g = e.accelerationIncludingGravity; if(!g) return;
  const ax = (g.x??0)/9.80665, ay=(g.y??0)/9.80665;
  const { sx } = toScreenAxes(ax, ay, screenAngle());
  tiltX += 0.12 * ((Math.abs(sx)<DEADZONE?0:sx) - tiltX); // ローパス
},{passive:true});

/* ===== iOS許可 ===== */
async function askPerm(){
  try{
    if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function'){
      await DeviceMotionEvent.requestPermission();
    }
    if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function'){
      await DeviceOrientationEvent.requestPermission();
    }
  }catch(e){ console.warn(e); }
  permBtn.classList.add('hidden');
}
const needMotionPerm = window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission==='function';
const needOrientPerm = window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission==='function';
if (needMotionPerm || needOrientPerm) permBtn.classList.remove('hidden');
permBtn.addEventListener('click', askPerm, {once:true});
document.addEventListener('touchstart', askPerm, {once:true, passive:true});
document.addEventListener('click', askPerm, {once:true});

/* ===== PCフォールバック：マウスXで tiltX を作る ===== */
if (!('ontouchstart' in window)){
  window.addEventListener('mousemove', (e)=>{
    const nx = (e.clientX / innerWidth) * 2 - 1;
    tiltX += 0.2 * (nx - tiltX);
  });
}

/* ===== 直接ドラッグで揺らす（iPad等の保険） ===== */
let dragging=false, lastX=0, lastY=0;
function pointerPos(evt){ const t=evt.touches?evt.touches[0]:evt; 
  const r = svg.getBoundingClientRect(); return {x: (evt.clientX??t.clientX)-r.left, y:(evt.clientY??t.clientY)-r.top}; }
svg.addEventListener('pointerdown', e=>{ dragging=true; const p=pointerPos(e); lastX=p.x; lastY=p.y; });
svg.addEventListener('pointermove', e=>{
  if(!dragging) return;
  const p=pointerPos(e);
  // 下端質点にインパルス（速度相当=位置の差）を与える
  const i=N-1; pts[i].px -= (p.x-lastX)*0.5; pts[i].py -= (p.y-lastY)*0.5;
  lastX=p.x; lastY=p.y;
});
window.addEventListener('pointerup', ()=>dragging=false);

/* ===== 物理ステップ（Verlet） ===== */
let lastT = performance.now();
function step(now){
  const dt = Math.min(0.033, (now-lastT)/1000); lastT=now;
  const dt2 = dt*dt;

  // 1) 力：下向き重力 + 横力（傾き）
  const ax = tiltX * GAIN_X * invert;
  const ay = GRAVITY_Y;

  for(let i=1;i<N;i++){ // 先頭は固定なので除外
    const p = pts[i];
    const vx = (p.x - p.px)*(1 - AIR_DAMP);
    const vy = (p.y - p.py)*(1 - AIR_DAMP);
    p.px = p.x; p.py = p.y;
    p.x += vx + ax*dt2;
    p.y += vy + ay*dt2;
  }

  // 2) 制約：アンカー固定
  pts[0].x = anchor.x; pts[0].y = anchor.y;

  // 3) 距離制約（反復）
  for(let k=0;k<ITER;k++){
    // 先頭固定
    pts[0].x = anchor.x; pts[0].y = anchor.y;

    for(let i=0;i<N-1;i++){
      const p1 = pts[i], p2 = pts[i+1];
      let dx = p2.x - p1.x, dy = p2.y - p1.y;
      const dist = Math.hypot(dx,dy) || 1;
      const diff = (dist - SEG_LEN) / dist;
      // 端点ごとに半分ずつ修正（先頭は固定で動かさない）
      const correctionX = dx*diff*0.5, correctionY = dy*diff*0.5;
      if(i>0){ p1.x += correctionX; p1.y += correctionY; }
      p2.x -= correctionX; p2.y -= correctionY;
    }
  }

  // 4) 描画（滑らかなパス）
  let d = `M ${pts[0].x.toFixed(2)} ${pts[0].y.toFixed(2)}`;
  for(let i=1;i<N;i++){
    d += ` L ${pts[i].x.toFixed(2)} ${pts[i].y.toFixed(2)}`;
  }
  rope.setAttribute('d', d);
  bob.setAttribute('cx', pts[N-1].x);
  bob.setAttribute('cy', pts[N-1].y);

  requestAnimationFrame(step);
}
requestAnimationFrame(step);

/* ===== ちょい微調整したい人向け：数値ここ変えると効きます =====
   - もっと“プラプラ”→ ITERを少し下げる(6) or AIR_DAMPを下げる(0.005)
   - コシ強く→ ITER上げ(10〜12) / SEG_LENを短く / AIR_DAMP少し上げ
   - 反応を強める→ GAIN_X を 1200, 1500… と増やす
   - 小刻みなブレ→ DEADZONE を 0.03〜0.05 に
*/
</script>
</body>
</html>
