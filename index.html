<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ショートサーキット vs 分離（ひも3本・入力左右反転）</title>
<style>

  :root{ --ui:#111; --blue:#06c; --red:#c30; }

  body { margin:0; background:#fff; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

  svg { width:100%; height:100vh; display:block; }

  text { font-size:14px; fill:#333; }

  .legend { fill:#555; font-size:12px; }

  /* モーション許可ボタン */

  #perm { position:fixed; inset:0; margin:auto; width:max(220px,40vw); padding:1rem;

          background:#fff; border:1px solid #888; border-radius:.5rem; box-shadow:0 4px 12px rgba(0,0,0,.2); }

  #perm.hidden{ display:none; }

  /* ツールバー */

  .toolbar{ position:fixed; top:10px; right:10px; display:flex; gap:.5rem; z-index:5; }

  .toolbar button{ padding:.5rem .75rem; border:1px solid #bbb; background:#fff; border-radius:.5rem; cursor:pointer; font-size:14px; }

  .toolbar button:active{ transform: translateY(1px); }
</style>
</head>
<body>
<div class="toolbar">
<button id="toggle-mirror" title="入力の左右を反転">左右反転（入力）</button>
</div>
<svg id="stage" viewBox="0 0 600 400" aria-label="ショートサーキット vs 分離 実験">
<!-- ショート型（左：黒） -->
<path id="rope-short" d="" stroke="#111" stroke-width="3" fill="none"/>
<circle id="bob-short" r="8" fill="#111"/>
<text x="100" y="30">ショートサーキット型</text>
<!-- 分離型（右：青=ユーザー入力） -->
<path id="rope-user" d="" stroke="#06c" stroke-width="3" fill="none"/>
<circle id="bob-user" r="8" fill="#06c"/>
<text x="400" y="30">分離型（青=ユーザー）</text>
<!-- 分離型（右：赤=システム出力） -->
<path id="rope-sys" d="" stroke="#c30" stroke-width="3" fill="none"/>
<circle id="bob-sys" r="8" fill="#c30"/>
<text x="400" y="210" class="legend">赤=システム出力（低周波化・遅延）</text>
</svg>
<button id="perm" class="hidden">センサーを有効にする</button>
<script>

/*********************************

 * ひも物理（Verlet + 距離拘束）

 *********************************/

class Rope{

  constructor(anchorX, anchorY){

    this.N = 12;       // ノード数

    this.SEG = 10;     // セグメント長（px）

    this.ITER = 6;     // 拘束反復回数

    this.anchor = { x: anchorX, y: anchorY };

    this.pts = Array.from({length: this.N}, (_, i) => ({

      x: anchorX, y: anchorY + i * this.SEG,

      px: anchorX, py: anchorY + i * this.SEG

    }));

    this.path = null; this.bob = null;

  }

  attach(pathEl, bobEl){ this.path = pathEl; this.bob = bobEl; }

  step(ax, ay, dt){

    const pts = this.pts, N = this.N;

    // 位置更新（Verlet）

    for(let i=1; i<N; i++){

      const p = pts[i];

      const vx = (p.x - p.px) * 0.99;  // 減衰

      const vy = (p.y - p.py) * 0.99;

      p.px = p.x; p.py = p.y;

      p.x += vx + ax * dt * dt;

      p.y += vy + ay * dt * dt;

    }

    // アンカー固定

    pts[0].x = this.anchor.x; pts[0].y = this.anchor.y;

    // 距離拘束

    for(let k=0; k<this.ITER; k++){

      pts[0].x = this.anchor.x; pts[0].y = this.anchor.y;

      for(let i=0; i<N-1; i++){

        const p1 = pts[i], p2 = pts[i+1];

        let dx = p2.x - p1.x, dy = p2.y - p1.y;

        const dist = Math.hypot(dx, dy) || 1;

        const diff = (dist - this.SEG) / dist;

        const cx = dx * diff * 0.5, cy = dy * diff * 0.5;

        if(i>0){ p1.x += cx; p1.y += cy; }

        p2.x -= cx; p2.y -= cy;

      }

    }

    // SVG 更新

    let d = `M${pts[0].x} ${pts[0].y}`;

    for(let i=1; i<N; i++){ d += `L${pts[i].x} ${pts[i].y}`; }

    this.path.setAttribute('d', d);

    this.bob.setAttribute('cx', pts[N-1].x);

    this.bob.setAttribute('cy', pts[N-1].y);

  }

}

/*********************************

 * デバイス傾き入力

 *********************************/

let tilt = { x: 0, y: 1 };  // 画面座標系：右(+x)・下(+y)

let MIRROR_X = false;       // 入力の左右だけ反転

function screenAngle(){

  if(screen.orientation && typeof screen.orientation.angle === 'number') return screen.orientation.angle;

  return 0;

}

function toScreenAxes(ax, ay, ang){

  const t = ang * Math.PI/180, c = Math.cos(t), s = Math.sin(t);

  return { sx: ax*c + ay*s, sy: -ax*s + ay*c };

}

function enableMotionIfNeeded(){

  const btn = document.getElementById('perm');

  const needsPerm = typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function';

  if(needsPerm){

    btn.classList.remove('hidden');

    btn.onclick = async () => {

      try{

        const st = await DeviceMotionEvent.requestPermission();

        if(st === 'granted'){

          window.addEventListener('devicemotion', onMotion, { passive:true });

          btn.classList.add('hidden');

        }

      }catch(e){ console.warn(e); }

    };

  }else{

    window.addEventListener('devicemotion', onMotion, { passive:true });

  }

}

function onMotion(e){

  const g = e.accelerationIncludingGravity; if(!g) return;

  const ax = (g.x ?? 0) / 9.8;  // 1g → 1.0

  const ay = (g.y ?? 0) / 9.8;

  const ang = screenAngle();

  const { sx, sy } = toScreenAxes(ax, ay, ang);

  tilt.x = sx; tilt.y = sy;

}

// キーボード代替（PC検証用）

(function setupKeyboard(){

  let vx=0, vy=0;

  window.addEventListener('keydown', (e)=>{

    if(e.key==='ArrowLeft') vx=-0.6; if(e.key==='ArrowRight') vx=0.6;

    if(e.key==='ArrowUp') vy=-0.6; if(e.key==='ArrowDown') vy=0.6;

    if(e.key===' ') { vx=0; vy=0; }

    tilt.x = vx; tilt.y = vy || 1;

  });

})();

/*********************************

 * セットアップ & ループ

 *********************************/

const ropeShort = new Rope(100, 60);   // 左上アンカー

const ropeUser  = new Rope(450, 60);   // 右上アンカー

const ropeSys   = new Rope(450, 240);  // 右下アンカー

ropeShort.attach(document.getElementById('rope-short'), document.getElementById('bob-short'));

ropeUser.attach(document.getElementById('rope-user'),   document.getElementById('bob-user'));

ropeSys.attach(document.getElementById('rope-sys'),     document.getElementById('bob-sys'));

let sys = { x: 0, y: 0 };        // システム出力のローパス状態

const SYS_ALPHA = 0.08;          // 小さいほど遅く滑らか

let lastT = performance.now();

function loop(t){

  const dt = Math.min(0.032, (t - lastT) / 1000); // 安定のため最大32ms

  lastT = t;

  // 入力スケール（Xのみ左右反転対応）

  const ax = (tilt.x * (MIRROR_X ? -1 : 1)) * 120;

  const ay = (tilt.y + 1.0) * 120;

  // 黒：ショートサーキット（入力=出力）

  ropeShort.step(ax, ay, dt);

  // 青：分離（ユーザー入力＝生値）

  ropeUser.step(ax, ay, dt);

  // 赤：分離（システム出力＝ローパス）

  sys.x += (ax - sys.x) * SYS_ALPHA;

  sys.y += (ay - sys.y) * SYS_ALPHA;

  ropeSys.step(sys.x, sys.y, dt);

  requestAnimationFrame(loop);

}

// 起動

enableMotionIfNeeded();

requestAnimationFrame(loop);

// 入力左右反転ボタン

const btnMirror = document.getElementById('toggle-mirror');

btnMirror.addEventListener('click', ()=>{

  MIRROR_X = !MIRROR_X;

  btnMirror.textContent = MIRROR_X ? '左右反転（入力：ON）' : '左右反転（入力）';

});
</script>
</body>
</html>
 
