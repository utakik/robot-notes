#pendulum {
  transform-origin: top center;
  will-change: transform; /* ブラウザに最適化のヒント */
  display: inline-block;
}

<script>
// ====== 調整用パラメータ ======
const DEADZONE_G = 0.04;     // これ未満は0扱い（微振動カット）
const ALPHA = 0.12;          // ローパス係数（小さいほどなめらか）
const STIFFNESS = 18.0;      // ばね係数（強いと復元が速い）
const DAMPING = 3.2;         // 減衰（大きいほどすぐ止まる）
const MAX_ANGLE_DEG = 22;    // 見た目の最大振れ角
const DRIVE_GAIN = 0.9;      // 入力→トルクの増幅

// ====== 要素取得 ======
const pendulum = document.getElementById('pendulum');
if (!pendulum) { console.warn('pendulum要素が見つかりません'); }

// ====== センサー許可（iOSなど） ======
async function askPermissionIfNeeded() {
  try {
    if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
      const r = await DeviceMotionEvent.requestPermission();
      // 必要なら結果でUI分岐
    }
    if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
      const r2 = await DeviceOrientationEvent.requestPermission();
    }
  } catch(e) { console.warn(e); }
}
document.addEventListener('click', askPermissionIfNeeded, { once:true });
document.addEventListener('touchstart', askPermissionIfNeeded, { once:true });

// ====== 入力（加速度/姿勢）をローパス＆デッドゾーン ======
let filtX = 0, filtY = 0; // g単位相当のなまし値
function applyDeadzone(v, dz) {
  return Math.abs(v) < dz ? 0 : v;
}

// devicemotion（傾けた方向の重力成分を拾う）
window.addEventListener('devicemotion', (e) => {
  if (!e.accelerationIncludingGravity) return;
  const ax = e.accelerationIncludingGravity.x / 9.80665; // g換算
  const ay = e.accelerationIncludingGravity.y / 9.80665;
  // デッドゾーン→ローパス
  const dx = applyDeadzone(ax, DEADZONE_G);
  const dy = applyDeadzone(ay, DEADZONE_G);
  filtX = filtX + ALPHA * (dx - filtX);
  filtY = filtY + ALPHA * (dy - filtY);
}, { passive:true });

// deviceorientation（gamma/betaから向き推定：機種差吸収用の予備）
let oriGamma = 0, oriBeta = 0;
window.addEventListener('deviceorientation', (e) => {
  // gamma: 左右（-90〜90）、beta: 前後（-180〜180）
  if (e.gamma != null) oriGamma = e.gamma / 90;  // おおよそ±1に正規化
  if (e.beta  != null) oriBeta  = e.beta  / 180; // おおよそ±1に正規化
}, { passive:true });

// デスクトップ確認用（マウスで傾き代用）
if (!('ontouchstart' in window)) {
  window.addEventListener('mousemove', (e) => {
    const nx = (e.clientX / window.innerWidth) * 2 - 1;  // -1..1
    const ny = (e.clientY / window.innerHeight) * 2 - 1; // -1..1
    // 混ぜる：PCではこちらが主、モバイルでは devicemotion が主
    filtX = filtX + ALPHA * ((nx*0.6) - filtX);
    filtY = filtY + ALPHA * ((ny*0.6) - filtY);
  });
}

// ====== 物理“振り子”シミュレーション（減衰付き） ======
let angle = 0;        // 現在角度 [rad]
let angVel = 0;       // 角速度
let lastT = performance.now();

function step(now) {
  const dt = Math.min(0.032, (now - lastT) / 1000); // 安定のためdt上限
  lastT = now;

  // 入力→トルク：横成分を採用（端末左右の傾きでぶら下げが揺れる感）
  // devicemotion優先、なければorientationを混ぜる
  const inputX = (Math.abs(filtX) > 0 ? filtX : oriGamma) * DRIVE_GAIN;

  // 単振り子っぽい運動： angle'' + c*angle' + k*angle = torque
  const torque = inputX;                    // 外力
  const accel = torque - DAMPING*angVel - STIFFNESS*angle;

  angVel += accel * dt;
  angle  += angVel * dt;

  // 見た目の制限（過大回転を避ける）
  const maxRad = MAX_ANGLE_DEG * Math.PI/180;
  angle = Math.max(-maxRad, Math.min(maxRad, angle));

  // 描画
  if (pendulum) {
    const deg = angle * 180/Math.PI;
    pendulum.style.transform = `rotate(${deg}deg)`;
  }

  requestAnimationFrame(step);
}
requestAnimationFrame(step);
</script>
