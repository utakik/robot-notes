<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>String Swing (sensor)</title>
<style>
  /* 全画面センタリング */
  html, body { height: 100%; margin: 0; }
  body { display: grid; place-items: center; font-family: system-ui, sans-serif; }

  /* ひも＋重り */
  #pendulum {
    transform-origin: top center;
    display: inline-block;
    will-change: transform;
    user-select: none;
    touch-action: manipulation;
  }
  .string {
    width: 2px;          /* ひもの太さ */
    height: 140px;       /* ひもの長さ */
    background: #111;
    margin: 0 auto;
  }
  .weight {
    width: 22px; height: 22px;
    background: #111;
    border-radius: 50%;
    margin: 0 auto;
  }

  /* 許可ボタン */
  #perm {
    position: fixed; inset: 0; margin: auto;
    width: max(220px, 40vw);
    padding: 1rem 1.2rem;
    border: 1px solid #888; border-radius: .6rem;
    background: #fff; font-size: 16px; cursor: pointer;
    box-shadow: 0 4px 16px rgba(0,0,0,.15);
  }
  #perm.hidden { display: none; }

  /* ヒント */
  .hint {
    position: fixed; top: 1rem; left: 50%; transform: translateX(-50%);
    font-size: 12px; opacity: .6;
  }
</style>
</head>
<body>
  <div id="pendulum">
    <div class="string"></div>
    <div class="weight"></div>
  </div>

  <button id="perm" class="hidden">センサーを有効にする</button>
  <div class="hint">モバイルは端末を傾けてください。PCはマウス移動でも揺れます。</div>

<script>
/* ========= 調整パラメータ ========= */
const DEADZONE_G    = 0.02;  // 微振動カット（0.03〜0.08くらいで調整）
const ALPHA         = 0.12;  // ローパス係数（小さいほど滑らか）
const STIFFNESS     = 18.0;  // 復元力（小→ゆったり／大→キビキビ）
const DAMPING       = 3.2;   // 減衰（大きいほど早く止まる）
const MAX_ANGLE_DEG = 22;    // 最大振れ角（見た目の上限）
const DRIVE_GAIN    = 2.9;   // 入力→トルク増幅

const pendulum = document.getElementById('pendulum');
const permBtn  = document.getElementById('perm');

/* ========= iOSなどの許可ボタン制御 ========= */
async function askSensorPermission() {
  try {
    if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
      await DeviceMotionEvent.requestPermission();
    }
    if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
      await DeviceOrientationEvent.requestPermission();
    }
  } catch (e) {
    console.warn('sensor permission:', e);
  }
  permBtn.classList.add('hidden');
}

// iOS系ならボタンを表示
const needMotionPerm = window.DeviceMotionEvent &&
                       typeof DeviceMotionEvent.requestPermission === 'function';
const needOrientPerm = window.DeviceOrientationEvent &&
                       typeof DeviceOrientationEvent.requestPermission === 'function';
if (needMotionPerm || needOrientPerm) {
  permBtn.classList.remove('hidden');
}

// ボタン or タップで要求
permBtn.addEventListener('click', askSensorPermission, { once: true });
document.addEventListener('touchstart', askSensorPermission, { once: true, passive: true });
document.addEventListener('click',       askSensorPermission, { once: true });

/* ========= 入力のローパス＋デッドゾーン ========= */
let filtX = 0, filtY = 0;
function dz(v, t){ return Math.abs(v) < t ? 0 : v; }

window.addEventListener('devicemotion', (e) => {
  const g = e.accelerationIncludingGravity;
  if (!g) return;
  const ax = (g.x ?? 0) / 9.80665;   // g単位に正規化
  const ay = (g.y ?? 0) / 9.80665;
  const dx = dz(ax, DEADZONE_G), dy = dz(ay, DEADZONE_G);
  filtX += ALPHA * (dx - filtX);
  filtY += ALPHA * (dy - filtY);
}, { passive:true });

let oriGamma = 0; // -1..1相当
window.addEventListener('deviceorientation', (e) => {
  if (e && e.gamma != null) oriGamma = e.gamma / 90; // 左右
}, { passive:true });

/* デスクトップ用：マウスで代用 */
if (!('ontouchstart' in window)) {
  window.addEventListener('mousemove', (e) => {
    const nx = (e.clientX / innerWidth) * 2 - 1;   // -1..1
    filtX += ALPHA * ((nx*0.6) - filtX);
  });
}

/* ========= 減衰付き“振り子”シミュレーション ========= */
let angle = 0;      // [rad]
let angVel = 0;
let lastT = performance.now();

function tick(now){
  const dt = Math.min(0.032, (now - lastT)/1000); lastT = now;

  // devicemotion優先、なければorientation
  const inputX = (Math.abs(filtX) > 0 ? filtX : oriGamma) * DRIVE_GAIN;

  // angle'' + DAMPING*angle' + STIFFNESS*angle = inputX
  const accel = inputX - DAMPING*angVel - STIFFNESS*angle;
  angVel += accel * dt;
  angle  += angVel * dt;

  // 見た目の上限
  const maxRad = MAX_ANGLE_DEG * Math.PI/180;
  if (angle >  maxRad) { angle =  maxRad; angVel *= 0.5; }
  if (angle < -maxRad) { angle = -maxRad; angVel *= 0.5; }

  // 描画
  pendulum.style.transform = `rotate(${angle*180/Math.PI}deg)`;

  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
</script>
</body>
</html>
