<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>String Swing (gravity → screen-axis)</title>
<style>
  html, body { height: 100%; margin: 0; }
  body { display: grid; place-items: center; font-family: system-ui, sans-serif; }
  #pendulum { transform-origin: top center; display:inline-block; will-change: transform; user-select:none; }
  .string { width: 2px; height: 140px; background:#111; margin:0 auto; }
  .weight { width: 22px; height: 22px; background:#111; border-radius:50%; margin:0 auto; }

  #perm { position:fixed; inset:0; margin:auto; width:max(220px,40vw); padding:1rem 1.2rem;
          border:1px solid #888; border-radius:.6rem; background:#fff; font-size:16px; cursor:pointer;
          box-shadow:0 4px 16px rgba(0,0,0,.15); }
  #perm.hidden { display:none; }

  .hint { position:fixed; top:.6rem; left:50%; transform:translateX(-50%); font-size:12px; opacity:.6; text-align:center; }

  #debug { position:fixed; right:.6rem; top:.6rem; font:12px/1.3 ui-monospace, Menlo, monospace;
           padding:.5rem .6rem; background:rgba(255,255,255,.9); border:1px solid #ddd; border-radius:.5rem; }
  #debug button, #debug label { margin-top:.4rem; display:block; }
  #debug input[type="range"] { width:160px; }
</style>
</head>
<body>
  <div id="pendulum">
    <div class="string"></div>
    <div class="weight"></div>
  </div>

  <button id="perm" class="hidden">センサーを有効にする</button>
  <div class="hint">端末を左右に傾けてください（画面の向きに自動追従）。PCはマウスでも可。</div>

  <div id="debug">
    <div>screen angle: <span id="sa">?</span>°</div>
    <div>g.x: <span id="gx">?</span> / g.y: <span id="gy">?</span></div>
    <div>screenX: <span id="sx">?</span></div>
    <div>angle°: <span id="an">?</span></div>
    <label>GAIN <input id="gain" type="range" min="0.5" max="4" step="0.1" value="2.0"></label>
    <label>DEADZONE <input id="dz" type="range" min="0" max="0.08" step="0.005" value="0.02"></label>
    <button id="cal">Calibrate（今の向きをゼロに）</button>
    <label><input id="inv" type="checkbox"> 反転（左右が逆に感じたら）</label>
  </div>

<script>
/* ===== 調整パラメータ ===== */
let DEADZONE = 0.02;          // 画面X成分のデッドゾーン（-1..1相当）
const ALPHA  = 0.12;          // ローパス
const STIFF  = 18.0;          // 復元力
const DAMP   = 3.2;           // 減衰
const MAX_DEG= 22;            // 見た目の最大角
let GAIN     = 2.0;           // 入力増幅

/* ===== 参照 ===== */
const pendulum = document.getElementById('pendulum');
const permBtn  = document.getElementById('perm');
const sa = document.getElementById('sa'), gx = document.getElementById('gx'), gy = document.getElementById('gy');
const sx = document.getElementById('sx'), an = document.getElementById('an');
const gainEl = document.getElementById('gain'), dzEl = document.getElementById('dz');
const calBtn = document.getElementById('cal'), invCb = document.getElementById('inv');
gainEl.addEventListener('input', ()=> GAIN = parseFloat(gainEl.value));
dzEl.addEventListener('input', ()=> DEADZONE = parseFloat(dzEl.value));

/* ===== iOSの許可 ===== */
async function askSensorPermission(){
  try {
    if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
      await DeviceMotionEvent.requestPermission();
    }
    if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
      await DeviceOrientationEvent.requestPermission();
    }
  } catch(e){ console.warn(e); }
  permBtn.classList.add('hidden');
}
const needMotionPerm = window.DeviceMotionEvent &&
                       typeof DeviceMotionEvent.requestPermission === 'function';
const needOrientPerm = window.DeviceOrientationEvent &&
                       typeof DeviceOrientationEvent.requestPermission === 'function';
if (needMotionPerm || needOrientPerm) permBtn.classList.remove('hidden');
permBtn.addEventListener('click', askSensorPermission, { once:true });
document.addEventListener('touchstart', askSensorPermission, { once:true, passive:true });
document.addEventListener('click',       askSensorPermission, { once:true });

/* ===== 画面の回転角を取得（0/90/180/270） ===== */
function screenAngle(){
  if (screen.orientation && typeof screen.orientation.angle === 'number') return screen.orientation.angle;
  if (typeof window.orientation === 'number') return ((window.orientation%360)+360)%360;
  return 0;
}

/* ===== 端末軸(ax,ay) → 画面軸(screenX,screenY) に回す =====
   iOSの加速度は端末座標。画面が90°回っていれば、そのぶん逆回転して
   「画面の右が +X」になるよう合わせる。az（奥行き）は使わない。 */
function toScreenAxes(ax, ay, angDeg){
  const t = angDeg * Math.PI/180;  // 画面を -t 回転させるのと同じ
  const c = Math.cos(t), s = Math.sin(t);
  const screenX =  ax*c + ay*s;    // 画面の左右
  const screenY = -ax*s + ay*c;    // 画面の上下（今回は未使用）
  return { screenX, screenY };
}

/* ===== 入力取得（重力ベクトル→画面X） ===== */
let filtSX = 0, lastAX=0, lastAY=0;
let zeroOffset = 0, invert = 1;

invCb.addEventListener('change', ()=> invert = invCb.checked ? -1 : 1);
calBtn.addEventListener('click', ()=> { zeroOffset = filtSX; });  // 今の値を0に

window.addEventListener('devicemotion', (e)=>{
  const g = e.accelerationIncludingGravity;
  if (!g) return;
  // gを「g単位」に正規化
  const ax = (g.x ?? 0) / 9.80665;
  const ay = (g.y ?? 0) / 9.80665;
  lastAX = ax; lastAY = ay;

  const ang = screenAngle();                 // 0/90/180/270
  const { screenX } = toScreenAxes(ax, ay, ang);

  // 画面Xのローパス＋ゼロ点補正＋反転＋デッドゾーン
  let v = invert * (screenX - zeroOffset);
  if (Math.abs(v) < DEADZONE) v = 0;
  filtSX += ALPHA * (v - filtSX);
}, { passive:true });

/* デスクトップ代用 */
if (!('ontouchstart' in window)) {
  window.addEventListener('mousemove', (e)=>{
    const nx = (e.clientX / innerWidth) * 2 - 1;
    filtSX += ALPHA * ((nx*0.6) - filtSX);
  });
}

/* ===== 減衰付き振り子 ===== */
let angle=0, vel=0, lastT=performance.now();
function tick(now){
  const dt = Math.min(0.032, (now-lastT)/1000); lastT = now;

  const input = filtSX * GAIN;                 // 画面左右のみ反映
  const acc   = input - DAMP*vel - STIFF*angle;
  vel += acc * dt;
  angle += vel * dt;

  const maxR = MAX_DEG*Math.PI/180;
  if (angle >  maxR){ angle =  maxR; vel *= 0.5; }
  if (angle < -maxR){ angle = -maxR; vel *= 0.5; }

  pendulum.style.transform = `rotate(${angle*180/Math.PI}deg)`;

  // デバッグ表示
  sa.textContent = screenAngle();
  gx.textContent = lastAX.toFixed(3);
  gy.textContent = lastAY.toFixed(3);
  sx.textContent = filtSX.toFixed(3);
  an.textContent = (angle*180/Math.PI).toFixed(1);

  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* 画面向きが変わったら、少し待ってからゼロ再取得すると安定 */
window.addEventListener('orientationchange', ()=> setTimeout(()=>{ zeroOffset = filtSX; }, 80));
if (screen.orientation) screen.orientation.addEventListener('change', ()=> setTimeout(()=>{ zeroOffset = filtSX; }, 80));
</script>
</body>
</html>
