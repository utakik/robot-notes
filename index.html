<!DOCTYPE html><html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ショートサーキット vs 分離（ひも3本・左右反転つき）</title>
<style>
  :root{ --ui: #111; --blue:#06c; --red:#c30; }
  body { margin:0; background:#fff; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  svg { width:100%; height:100vh; display:block; transition: transform .25s ease; }
  text { font-size:14px; fill:#333; }
  .legend { fill:#555; font-size:12px; }
  /* iOS 等のモーション許可ボタン（ダイアログ） */
  #perm { position:fixed; inset:0; margin:auto; width:max(220px,40vw); padding:1rem;
          background:#fff; border:1px solid #888; border-radius:.5rem; box-shadow:0 4px 12px rgba(0,0,0,.2); }
  #perm.hidden{ display:none; }
  /* ツールバー */
  .toolbar{ position:fixed; top:10px; right:10px; display:flex; gap:.5rem; z-index:5; }
  .toolbar button{ padding:.5rem .75rem; border:1px solid #bbb; background:#fff; border-radius:.5rem; cursor:pointer; font-size:14px; }
  .toolbar button:active{ transform: translateY(1px); }
  /* 左右反転時の見た目（テキストは反転打ち消しで可読維持） */
  body.mirror svg{ transform: scaleX(-1); }
  body.mirror text{ transform: scaleX(-1); transform-box: fill-box; transform-origin: center; }
</style>
</head>
<body><div class="toolbar">
  <button id="toggle-mirror" title="左右反転">左右反転</button>
</div><!-- =============================
     可視レイヤ（SVG）
     - 左: ショートサーキット型（黒）
     - 右上: 分離型 ユーザー入力（青）
     - 右下: 分離型 システム出力（赤）
     ※ 3本とも同じ物理エンジン(Rope)を共有
   ============================= --><svg id="stage" viewBox="0 0 600 400" aria-label="ショートサーキット vs 分離 実験">
  <!-- ショート型（左：黒） -->
  <!-- ▼ この2要素が1本のひもとおもり（bob） -->
  <path id="rope-short" d="" stroke="#111" stroke-width="3" fill="none"/>
  <circle id="bob-short" r="8" fill="#111"/>
  <text x="100" y="30">ショートサーキット型</text>  <!-- 分離型（右：青=ユーザー入力） -->  <!-- ▼ ユーザー傾き入力を直接駆動 -->  <path id="rope-user" d="" stroke="#06c" stroke-width="3" fill="none"/>
  <circle id="bob-user" r="8" fill="#06c"/>
  <text x="400" y="30">分離型（青=ユーザー）</text>  <!-- 分離型（右：赤=システム出力） -->  <!-- ▼ ユーザー入力をローパス処理した“出力”を駆動（処理遅延のモデル） -->  <path id="rope-sys" d="" stroke="#c30" stroke-width="3" fill="none"/>
  <circle id="bob-sys" r="8" fill="#c30"/>
  <text x="400" y="210" class="legend">赤=システム出力（低周波化・遅延）</text>
</svg><!-- iOS 等でのデバイスモーション許可用ボタン --><button id="perm" class="hidden">センサーを有効にする</button>

<script>
/*********************************
 * ひも物理（Verlet + 距離拘束）
 *********************************/
class Rope{
  constructor(anchorX, anchorY){
    this.N = 12;       // ノード数
    this.SEG = 10;     // セグメント長（px）
    this.ITER = 6;     // 拘束反復回数
    this.anchor = { x: anchorX, y: anchorY };
    this.pts = Array.from({length: this.N}, (_, i) => ({
      x: anchorX,
      y: anchorY + i * this.SEG,
      px: anchorX,
      py: anchorY + i * this.SEG
    }));
    this.path = null; this.bob = null;
  }
  attach(pathEl, bobEl){ this.path = pathEl; this.bob = bobEl; }
  step(ax, ay, dt){
    const pts = this.pts, N = this.N;
    // 位置更新（Verlet）
    for(let i=1; i<N; i++){
      const p = pts[i];
      const vx = (p.x - p.px) * 0.99;            // 減衰（空気抵抗）
      const vy = (p.y - p.py) * 0.99;
      p.px = p.x; p.py = p.y;
      p.x += vx + ax * dt * dt;                  // 加速度は px/frame^2 換算
      p.y += vy + ay * dt * dt;
    }
    // アンカー固定
    pts[0].x = this.anchor.x; pts[0].y = this.anchor.y;

    // 距離拘束（ロープ長保持）
    for(let k=0; k<this.ITER; k++){
      pts[0].x = this.anchor.x; pts[0].y = this.anchor.y; // 毎回原点復帰
      for(let i=0; i<N-1; i++){
        const p1 = pts[i], p2 = pts[i+1];
        let dx = p2.x - p1.x, dy = p2.y - p1.y;
        const dist = Math.hypot(dx, dy) || 1;
        const diff = (dist - this.SEG) / dist;
        const cx = dx * diff * 0.5, cy = dy * diff * 0.5;
        if(i > 0){ p1.x += cx; p1.y += cy; }     // アンカー以外を調整
        p2.x -= cx; p2.y -= cy;
      }
    }
    // SVG 更新
    let d = `M${pts[0].x} ${pts[0].y}`;
    for(let i=1; i<N; i++){ d += `L${pts[i].x} ${pts[i].y}`; }
    this.path.setAttribute('d', d);
    this.bob.setAttribute('cx', pts[N-1].x);
    this.bob.setAttribute('cy', pts[N-1].y);
  }
}

/*********************************
 * デバイス傾き入力
 *********************************/
let tilt = { x: 0, y: 1 }; // 画面座標系：右(+x)・下(+y)方向の“重力”成分

function screenAngle(){
  if(screen.orientation && typeof screen.orientation.angle === 'number') return screen.orientation.angle;
  return 0;
}
function toScreenAxes(ax, ay, ang){
  const t = ang * Math.PI/180, c = Math.cos(t), s = Math.sin(t);
  return { sx: ax*c + ay*s, sy: -ax*s + ay*c };
}

function enableMotionIfNeeded(){
  const btn = document.getElementById('perm');
  const needsPerm = typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function';
  if(needsPerm){
    btn.classList.remove('hidden');
    btn.onclick = async () => {
      try{
        const st = await DeviceMotionEvent.requestPermission();
        if(st === 'granted'){
          window.addEventListener('devicemotion', onMotion, { passive:true });
          btn.classList.add('hidden');
        }
      }catch(e){ console.warn(e); }
    };
  }else{
    // 権限不要な環境
    window.addEventListener('devicemotion', onMotion, { passive:true });
  }
}

function onMotion(e){
  const g = e.accelerationIncludingGravity; if(!g) return;
  // 物理g(≈9.8)で正規化して "1g" を 1.0 とする
  const ax = (g.x ?? 0) / 9.8;
  const ay = (g.y ?? 0) / 9.8;
  const ang = screenAngle();
  const { sx, sy } = toScreenAxes(ax, ay, ang);
  // 端末の傾きが右下に重力ベクトルを持つと (+x, +y)
  tilt.x = sx; tilt.y = sy;
}

// キーボード代替（PC検証用）: 矢印で傾き、スペースでリセット
(function setupKeyboard(){
  let vx=0, vy=0;
  window.addEventListener('keydown', (e)=>{
    if(e.key==='ArrowLeft') vx=-0.6; if(e.key==='ArrowRight') vx=0.6;
    if(e.key==='ArrowUp') vy=-0.6; if(e.key==='ArrowDown') vy=0.6;
    if(e.key===' ') { vx=0; vy=0; }
    tilt.x = vx; tilt.y = vy || 1; // デフォルトでやや下向き
  });
})();

/*********************************
 * セットアップ & ループ
 *********************************/
const ropeShort = new Rope(100, 60);   // 左上アンカー
const ropeUser  = new Rope(450, 60);   // 右上アンカー
const ropeSys   = new Rope(450, 240);  // 右下アンカー

// DOM 紐付け
ropeShort.attach(
  document.getElementById('rope-short'),
  document.getElementById('bob-short')
);
ropeUser.attach(
  document.getElementById('rope-user'),
  document.getElementById('bob-user')
);
ropeSys.attach(
  document.getElementById('rope-sys'),
  document.getElementById('bob-sys')
);

// システム出力のローパス用状態
let sys = { x: 0, y: 0 };
const SYS_ALPHA = 0.08; // 小さいほど遅延・平滑化が強い

let lastT = performance.now();
function loop(t){
  const dt = Math.min(0.032, (t - lastT) / 1000); // 安定のため最大32ms
  lastT = t;

  // 端末傾き→画面座標の“擬似重力”を px単位の加速度にスケール
  // 左右反転時は X 成分を反転させて、見た目と操作の整合を取る
  const sign = MIRROR ? -1 : 1;
  const ax = (tilt.x * sign) * 120;   // 入力スケール
  const ay = (tilt.y + 1.0) * 120;

  // ショートサーキット型：入力=出力=同一（黒）
  ropeShort.step(ax, ay, dt);

  // 分離型：ユーザー入力（青）は生値を使用
  ropeUser.step(ax, ay, dt);

  // 分離型：システム出力（赤）はローパス処理（遅延・平滑化）
  sys.x += (ax - sys.x) * SYS_ALPHA;
  sys.y += (ay - sys.y) * SYS_ALPHA;
  ropeSys.step(sys.x, sys.y, dt);

  requestAnimationFrame(loop);
}

// 起動
enableMotionIfNeeded();
requestAnimationFrame(loop);

// 左右反転ボタン
const btnMirror = document.getElementById('toggle-mirror');
btnMirror.addEventListener('click', ()=>{
  MIRROR_X = !MIRROR_X; // 見た目は一切変えず、入力Xの符号だけを切り替える
  btnMirror.textContent = MIRROR_X ? '左右反転（入力：ON）' : '左右反転（入力）';
});
</script></body>
</html>
